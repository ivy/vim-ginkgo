//go:generate go run gensyntax.go

// Command gensyntax generates a vim syntax for Ginkgo and related packages by
// parsing and searching their exported matchers and assertions.
package main

import (
	"flag"
	"fmt"
	"go/importer"
	"go/types"
	"html/template"
	"log"
	"os"
	"sort"
	"time"
)

const warning = `" This file was generated by gensyntax.go on %s
" DO NOT modify this file by hand!
" Instead, edit ginkgo.vim.tpl and/or run: go generate`

var (
	packages = []string{
		"github.com/onsi/gomega",
		"github.com/onsi/gomega/gbytes",
		"github.com/onsi/gomega/gexec",
		"github.com/onsi/gomega/ghttp",
		"github.com/onsi/gomega/gstruct",
		"github.com/sclevine/agouti/matchers",
	}

	srcImporter = importer.For("source", nil)
)

func init() {
	flag.Parse()
}

func main() {
	tpl, err := template.ParseFiles("syntax/ginkgo.vim.tpl")
	if err != nil {
		log.Fatal(err)
	}

	keywords := &Keywords{
		Assertions: make([]string, 0),
		Matchers:   make([]string, 0),
	}
	if err := keywords.Search(packages); err != nil {
		log.Fatal(err)
	}
	log.Printf("Found %d assertions and %d matchers",
		len(keywords.Assertions), len(keywords.Matchers))

	f, err := os.OpenFile("syntax/ginkgo.vim",
		os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, err = f.Write([]byte(fmt.Sprintf(warning,
		time.Now().UTC().Format(time.RFC1123Z))))
	if err != nil {
		log.Fatal(err)
	}

	tpl.Execute(f, keywords)
}

type Keywords struct {
	Assertions []string
	Matchers   []string
}

func (k *Keywords) Search(pkgs []string) (first error) {
	for _, path := range pkgs {
		log.Printf("Searching %s...", path)
		pkg, err := srcImporter.Import(path)
		if err != nil {
			first = err
			return
		}

		for _, fn := range filterExports(pkg) {
			sig := fn.Type().(*types.Signature)
			res := sig.Results()
			if res != nil && res.Len() == 1 {
				if named, ok := res.At(0).Type().(*types.Named); ok {
					switch named.Obj().Name() {
					case "Assertion", "AsyncAssertion":
						k.Assertions = append(k.Assertions, fn.Name())
					case "GomegaMatcher":
						k.Matchers = append(k.Matchers, fn.Name())
					}
				}
			}
		}
	}
	sort.Strings(k.Assertions)
	sort.Strings(k.Matchers)
	return
}

func filterExports(pkg *types.Package) (funcs []*types.Func) {
	for _, name := range pkg.Scope().Names() {
		obj := pkg.Scope().Lookup(name)
		if obj != nil && obj.Exported() {
			if fn, ok := obj.(*types.Func); ok {
				funcs = append(funcs, fn)
			}
		}
	}
	return
}
